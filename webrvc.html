<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RV-C Tool: Disconnected</title>
  <style>
    body { font-family: monospace; }
    #logContainer {
      height: 800px;
      overflow-y: auto;
      border: 1px solid #ccc;
    }
    #logTable {
      width: 100%;
      border-collapse: collapse;
    }
    #logTable th, #logTable td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
    #logTable thead th {
      position: sticky;
      top: 0;
      background-color: #f0f0f0;
      z-index: 1;
    }
    button, input[type="file"] { 
      margin: 5px; 
      background-color: #f0f0f0; 
      color: #000; 
      border: 1px solid #ccc; 
      padding: 5px 10px;
      cursor: pointer;
    }
    button:disabled {
      background-color: #ccc;
      color: #666;
    }
    #sourceTable {
      border-collapse: collapse;
      border: 1px solid #ccc;
      width: auto;
      float: left;
    }
    #sourceTable th, #sourceTable td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: left;
    }
    #clear {
      clear: both;
    }
    #logSection {
      margin-bottom: 20px;
    }
    @media (prefers-color-scheme: dark) {
      body { background-color: #121212; color: #e0e0e0; }
      #logContainer, #sourceTable { border-color: #444; }
      #logTable th, #logTable td, #sourceTable th, #sourceTable td { border-color: #444; }
      #logTable thead th {
        background-color: #333;
      }
      button, input[type="file"] { 
        background-color: #333; 
        color: #e0e0e0; 
        border-color: #444; 
      }
    }
  </style>
</head>
<body>
  <button id="connectButton">Connect</button>
  <button id="disconnectButton" disabled>Disconnect</button>
  <button id="clearButton">Clear</button>
  <button id="exportCsvButton">Export to CSV</button>
  <button id="pauseButton" disabled>Pause</button>
  
  <label><input type="checkbox" id="autoScroll" checked> Auto-Scroll</label>
  <label><input type="checkbox" id="showUnparsed" checked> Show Unparsed Packets</label>
  <label><input type="checkbox" id="includeDate" checked> Include Date in Timestamp</label>
  
  <br><br>

  <div id="logSection">
    <div id="logContainer">
      <table id="logTable">
        <thead>
          <tr>
            <th>Timestamp</th>
            <th>ID</th>
            <th>DGN</th>
            <th>Src</th>
            <th>Payload</th>
            <th>Packet Name</th>
            <th>Parameters</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <div id="sourceSection">
    <table id="sourceTable">
      <thead>
        <tr>
          <th>Source Address</th>
          <th>Packet Count</th>
          <th>Show in Logs</th>
        </tr>
      </thead>
      <tbody>
      </tbody>
    </table>
  </div>

  <div id="clear"></div>

  <div>
    <h2>Send Command</h2>
    Priority:
    <select id="priority">
      <option value="0">0</option>
      <option value="1">1</option>
      <option value="2">2</option>
      <option value="3">3</option>
      <option value="4">4</option>
      <option value="5">5</option>
      <option value="6">6</option>
      <option value="7">7</option>
    </select>
    DGN: <input type="text" id="dgn" maxlength="5" placeholder="DGN (5 hex digits)">
    Source Address: <input type="text" id="sourceAddr" maxlength="2" placeholder="Src (2 hex digits)">
    Payload: <input type="text" id="payload" placeholder="Payload (hex)">
    <button id="sendButton" disabled>Send</button>
  </div>

  <h2>Upload Packet Definitions</h2>
  <input type="file" id="fileInput">
  <div id="uploadStatus">No packet definitions loaded</div>
  <div id="packetDefinitionsTable"></div>

  <script>
    const connectButton = document.getElementById('connectButton');
    const disconnectButton = document.getElementById('disconnectButton');
    const clearButton = document.getElementById('clearButton');
    const exportCsvButton = document.getElementById('exportCsvButton');
    const pauseButton = document.getElementById('pauseButton');
    const sendButton = document.getElementById('sendButton');
    const prioritySelect = document.getElementById('priority');
    const dgnInput = document.getElementById('dgn');
    const sourceAddrInput = document.getElementById('sourceAddr');
    const payloadInput = document.getElementById('payload');
    const autoScrollCheckbox = document.getElementById('autoScroll');
    const showUnparsedCheckbox = document.getElementById('showUnparsed');
    const logTable = document.getElementById('logTable').querySelector('tbody');
    const sourceTable = document.getElementById('sourceTable').querySelector('tbody');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const includeDate = document.getElementById('includeDate').checked;

    let port;
    let reader;
    let outputStream;
    let paused = false;
    let sourceAddresses = {};
    let packetsOfInterest = [];

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            packetsOfInterest = data.packets;
            uploadStatus.textContent = `${packetsOfInterest.length} packet types defined:`;
            generatePacketDefinitionsTable(packetsOfInterest);
          } catch (error) {
            uploadStatus.textContent = 'Error parsing JSON';
            console.error('Error parsing JSON:', error);
          }
        };
        reader.readAsText(file);
      }
    });

    function generatePacketDefinitionsTable(packets) {
      const tableContainer = document.getElementById('packetDefinitionsTable');
      tableContainer.innerHTML = ''; // Clear previous table if any

      if (packets.length > 0) {
        const table = document.createElement('table');
        table.style.width = 'auto';
        table.style.borderCollapse = 'collapse';
        
        packets.forEach(packet => {
          const row = document.createElement('tr');
          const cell = document.createElement('td');
          cell.textContent = packet.name;
          if (packet.text_color) cell.style.color = packet.text_color;
          if (packet.background_color) cell.style.backgroundColor = packet.background_color;
          cell.style.padding = '5px';
          cell.style.border = '1px solid #ccc';
          row.appendChild(cell);
          table.appendChild(row);
        });

        tableContainer.appendChild(table);
      }
    }

    connectButton.addEventListener('click', async () => {
      try {
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 250000 });
        document.title = 'RV-C Tool: Connected';

        reader = port.readable.getReader();
        outputStream = port.writable.getWriter();

        await outputStream.write(new TextEncoder().encode('O\r')); // Open CAN channel
        await outputStream.write(new TextEncoder().encode('S5\r')); // Set CAN bit rate to 250000

        readData();

        connectButton.disabled = true;
        disconnectButton.disabled = false;
        sendButton.disabled = false;
        pauseButton.disabled = false;
      } catch (error) {
        document.title = 'RV-C Tool: Error Connecting';
        console.error(error);
      }
    });

    disconnectButton.addEventListener('click', async () => {
      try {
        await outputStream.write(new TextEncoder().encode('C\r')); // Close CAN channel
        await reader.cancel();
        await port.close();
        document.title = 'RV-C Tool: Disconnected';

        connectButton.disabled = false;
        disconnectButton.disabled = true;
        sendButton.disabled = true;
        pauseButton.disabled = true;
      } catch (error) {
        document.title = 'RV-C Tool: Error Disconnecting';
        console.error(error);
      }
    });

    sendButton.addEventListener('click', async () => {
      const priority = prioritySelect.value;
      const dgn = dgnInput.value;
      const sourceAddr = sourceAddrInput.value;
      const payload = payloadInput.value.replace(/[^0-9a-fA-F]/g, '');
      if (dgn.length !== 5 || !/^[0-1]/.test(dgn)) {
        alert('DGN must be 5 hex digits and start with 0 or 1.');
        return;
      }
      if (sourceAddr.length !== 2 || !/^[0-9a-fA-F]{2}$/.test(sourceAddr)) {
        alert('Source Address must be 2 hex digits.');
        return;
      }
      const id = `${priority}${dgn}${sourceAddr}`;
      const len = (payload.length / 2).toString(16).toUpperCase().padStart(1, '0');
      const command = `T${id}${len}${payload}\r`;

      await outputStream.write(new TextEncoder().encode(command));
      dgnInput.value = '';
      sourceAddrInput.value = '';
      payloadInput.value = '';
    });

    clearButton.addEventListener('click', () => {
      logTable.innerHTML = '';
      sourceAddresses = {};
      updateSourceTable();
    });

    exportCsvButton.addEventListener('click', () => {
      const csvContent = getCsvContent();
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'RVC_Log.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    pauseButton.addEventListener('click', () => {
      paused = !paused;
      pauseButton.textContent = paused ? 'Resume' : 'Pause';
    });

    async function readData() {
      const decoder = new TextDecoder();
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            break;
          }
          if (!paused) {
            const text = decoder.decode(value);
            processCanData(text);
          }
        }
      } catch (error) {
        console.error(error);
      }
    }

    function processCanData(data) {
      const lines = data.trim().split('\r');
      for (const line of lines) {
        if (line.startsWith('T') && line.length >= 11) {
          const id = line.substring(1, 9);
          const dgn = (parseInt(id.substring(1, 2), 16) & 1).toString(16) + id.substring(2, 6);
          const sourceAddress = id.substring(6, 8);
          const payload = line.substring(10);

          if (!sourceAddresses[sourceAddress]) {
            sourceAddresses[sourceAddress] = { count: 0, show: true };
          }
          sourceAddresses[sourceAddress].count++;
          updateSourceTable();

          let timestamp = new Date().toISOString().replace('T', ' ').replace('Z', '');
          if (!includeDate) {
            timestamp = timestamp.split(' ')[1];
          }
          let logEntry = [timestamp, id, dgn, sourceAddress, payload];

          const packet = packetsOfInterest.find(p => (parseInt(dgn, 16) & parseInt(p.dgn_mask, 16)) === parseInt(p.dgn_filter, 16));
          if (packet && sourceAddresses[sourceAddress].show) {
            logEntry.push(packet.name);
            const params = packet.parameters.map(param => {
              const value = extractParameter(payload, param.start_bit, param.length);
              const translatedValue = param.translations ? param.translations[value] : value;
              return `${param.name}: ${translatedValue}`;
            }).join(', ');
            logEntry.push(params);
            addLogEntryToTable(logEntry, packet.text_color, packet.background_color);
          } else if (showUnparsedCheckbox.checked && sourceAddresses[sourceAddress].show) {
            logEntry.push('');
            logEntry.push('');
            addLogEntryToTable(logEntry);
          } else {
            continue; // Skip logging this entry if showUnparsed is not checked
          }
        }
      }
    }

    function addLogEntryToTable(logEntry, textColor = '', backgroundColor = '') {
      const row = document.createElement('tr');
      if (textColor) row.style.color = textColor;
      if (backgroundColor) row.style.backgroundColor = backgroundColor;
      logEntry.forEach(cellData => {
        const cell = document.createElement('td');
        cell.textContent = cellData;
        row.appendChild(cell);
      });
      logTable.appendChild(row);

      if (autoScrollCheckbox.checked) {
        document.getElementById('logContainer').scrollTop = document.getElementById('logContainer').scrollHeight;
      }
    }

    function extractParameter(payload, startBit, length) {
      const startByte = Math.floor(startBit / 8);
      const endByte = Math.ceil((startBit + length) / 8);
      const rawBytes = payload.substring(startByte * 2, endByte * 2);
      const rawBits = parseInt(rawBytes, 16).toString(2).padStart((endByte - startByte) * 8, '0');
      const paramBits = rawBits.substring(startBit % 8, (startBit % 8) + length);
      return parseInt(paramBits, 2);
    }

    function updateSourceTable() {
      sourceTable.innerHTML = '';
      const sortedAddresses = Object.entries(sourceAddresses).sort((a, b) => b[1].count - a[1].count);
      for (const [address, info] of sortedAddresses) {
        const row = document.createElement('tr');
        const addressCell = document.createElement('td');
        const countCell = document.createElement('td');
        const showCell = document.createElement('td');
        const showCheckbox = document.createElement('input');
        showCheckbox.type = 'checkbox';
        showCheckbox.checked = info.show;
        showCheckbox.addEventListener('change', () => {
          sourceAddresses[address].show = showCheckbox.checked;
        });

        addressCell.textContent = address;
        countCell.textContent = info.count;
        showCell.appendChild(showCheckbox);

        row.appendChild(addressCell);
        row.appendChild(countCell);
        row.appendChild(showCell);
        sourceTable.appendChild(row);
      }
    }

    function getCsvContent() {
      const rows = Array.from(logTable.querySelectorAll('tr'));
      const csvContent = rows.map(row => {
        const cols = Array.from(row.querySelectorAll('td')).map(td => td.textContent);
        return cols.join(',');
      }).join('\n');
      return csvContent;
    }
  </script>
</body>
</html>
